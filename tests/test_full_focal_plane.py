import numpy as np
import galsim

import os

from imsim.camera import get_camera
from imsim.full_focal_plane import gather_out_of_bounds_photons
from imsim.utils import focal_to_pixel


def test_gather_out_of_bounds_photons():
    """Make sure that photons inside and outside the image bounds are gathered correctly."""
    xymin = 0
    xymax = 100
    nphotons = 10
    bounds = galsim.BoundsI(xymin, xymax, xymin, xymax)

    rng = np.random.default_rng(42)

    # Create test photon array
    photons = galsim.PhotonArray(nphotons)
    photons.flux = np.ones(nphotons)

    # Test all photons with random positions inside the bounds -- none should be gathered.
    photons.x = rng.uniform(xymin, xymax, size=nphotons)
    photons.y = rng.uniform(xymin, xymax, size=nphotons)
    gathered_photons = gather_out_of_bounds_photons(bounds, photons)
    assert len(gathered_photons) == 0, "Expected 0 photons to be gathered when all are inside the bounds."

    # Test all photons with random positions outside the bounds -- all should be gathered.
    photons.x = rng.uniform(xymax+100, xymax+200, size=nphotons)
    photons.y = rng.uniform(xymin+100, xymax+200, size=nphotons)
    gathered_photons = gather_out_of_bounds_photons(bounds, photons)
    assert len(gathered_photons) == nphotons, "Expected all {} photons to be gathered when they are outside the bounds.".format(nphotons)

    # Test a mix of photons inside and outside the bounds.
    n_inside = nphotons // 2
    n_outside = nphotons - n_inside
    photons.x[:n_inside] = rng.uniform(xymin, xymax, size=n_inside)
    photons.x[n_inside:] = rng.uniform(xymax+100, xymax+200, size=n_outside)
    photons.y[:n_inside] = rng.uniform(xymin, xymax, size=n_inside)
    photons.y[n_inside:] = rng.uniform(xymin+100, xymax+200, size=n_outside)
    gathered_photons = gather_out_of_bounds_photons(bounds, photons)
    assert len(gathered_photons) == n_outside, "Of {} photons total, expected the {} outside the bounds to be gathered.".format(nphotons, n_outside)


def process_off_detector_photons_output(pa_list):
    # Given a list of photon arrays (as would be generated by
    # gather_out_of_bounds_photons across an image's photon pools), create a
    # config and process it to write the photons to file.
    base = {
        "det_name": "R22_S11",
        "output": {
            "camera": "LsstCam",
            "off_detector_photons": {
                "dir": "output",
                "file_name": "off_det_photons.fits",
            },
        },
        "file_num": 0,
        "off_detector_photons": pa_list,
    }

    # This should now generate a concatenated photon array in
    # output/off_det_photons.fits with positions transformed to focal plane
    # coordinates.
    galsim.config.SetupExtraOutput(base)
    galsim.config.ProcessExtraOutputsForImage(base)
    galsim.config.WriteExtraOutputs(base, [])

    # Check that the output file exists.
    assert os.path.exists("output/off_det_photons.fits"), "Output file 'output/off_det_photons.fits' was not created."

    # Assert that the photons stored in the output match. They should need to be
    # transformed from focal plane to detector coordinates first.
    output_photons = galsim.PhotonArray.read("output/off_det_photons.fits")
    if len(output_photons) > 0:
        detector = get_camera(base['output']['camera'])[base['det_name']]
        output_photons.x, output_photons.y = focal_to_pixel(output_photons.x, output_photons.y, detector)
    focal_plane_photons = galsim.PhotonArray.concatenate(pa_list)
    assert np.allclose(output_photons.x, focal_plane_photons.x), "X coordinates of output photons do not match original photons in focal plane coordinates."
    assert np.allclose(output_photons.y, focal_plane_photons.y), "Y coordinates of output photons do not match original photons in focal plane coordinates."
    assert np.allclose(output_photons.flux, focal_plane_photons.flux), "Flux of output photons does not match original photons."

    # Final cleanup.
    os.remove("output/off_det_photons.fits")


def test_off_detector_photons_output():
    # Create a list of photon arrays which are all of > 0 length, corresponding
    # to the case for which all photon pools found and stored off-detector
    # photons.
    nphotons_total = 100
    nbatch = 10
    nphot_per_batch = nphotons_total // nbatch
    pa_list = [galsim.PhotonArray(nphot_per_batch,
                                  x=np.arange(i*nphot_per_batch, (i+1)*nphot_per_batch),
                                  y=np.arange(i*nphot_per_batch, (i+1)*nphot_per_batch),
                                  flux=np.ones(nphot_per_batch))
               for i in range(nbatch)]
    process_off_detector_photons_output(pa_list)


def test_off_detector_photons_output_with_none():
    # A list of empty photon arrays should produce output with an empty photon
    # array. This is the case if no photons were found outside the image bounds
    # for the entire image.
    nbatch = 10
    pa_list = [galsim.PhotonArray(N=0) for _ in range(nbatch)]
    process_off_detector_photons_output(pa_list)


def test_off_detector_photons_output_with_mix():
    # Create a list of photon arrays of different sizes, including some empty
    # ones. This is the case when some photon pools contained off-detector
    # photons and some didn't.
    rng = np.random.default_rng(42)
    n_off_det = [0, 10, 20, 15, 0, 10, 0, 15, 0, 20, 10, 0]
    xymin = 0.0
    xymax = 100.0
    pa_list = [galsim.PhotonArray(nphot,
                                  x=rng.uniform(xymin, xymax, size=nphot),
                                  y=rng.uniform(xymin, xymax, size=nphot),
                                  flux=np.ones(nphot))
               for nphot in n_off_det]
    process_off_detector_photons_output(pa_list)

# TODO: Need some tests for the OffDetectorPhotonsLoader and
# LSST_FocalPlaneImageBuilder.


if __name__ == "__main__":
    testfns = [v for k, v in vars().items() if k.startswith("test_") and callable(v)]
    for testfn in testfns:
        testfn()
